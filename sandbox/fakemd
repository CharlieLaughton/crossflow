#!/usr/bin/env python
#
# An MD simulation code proxy
#
import mdtraj as mdt
import numpy as np
import networkx as nx
from argparse import ArgumentParser

parser = ArgumentParser()
parser.add_argument('-c', '--crds', help='starting coordinates file')
parser.add_argument('-t', '--top', help='parameter/topology file')
parser.add_argument('-o', '--log', help='log file')
parser.add_argument('-r', '--restart', help='restart file')
parser.add_argument('-x', '--traj', help='trajectory file')
parser.add_argument('-n', '--nframes',type=int,  help='number of snapshots to produce')

args = parser.parse_args()
v = vars(args)
if not all(v.values()):
    parser.print_help()
    exit(1)

crds = args.crds
top  = args.top
log = args.log
restart = args.restart
traj = args.traj
n_frames = args.nframes

tcrds = mdt.load(crds, top=top)
n_atoms = tcrds.n_atoms
G = nx.Graph()
for b in tcrds.topology.bonds:
    G.add_edge(b[0].index, b[1].index)
trj = mdt.Trajectory(np.zeros((n_frames, n_atoms, 3)), tcrds.topology)
dv = np.zeros((n_atoms, 3))
trj.xyz[0] = tcrds.xyz[0]
for i in range(1, n_frames):
    v = np.random.rand(n_atoms, 3) - 0.5
    dv[:] = 0.0
    for j in range(n_atoms):
        if j in G:
            neigh = [n for n in G.neighbors(j)]
            dv[neigh] *= v[j] * 0.5
    v += dv
    trj.xyz[i] = trj.xyz[i-1] + v * 0.1
trj.save(traj)
trj[-1].save(restart)
rmsd = mdt.rmsd(trj, tcrds)
with open(log, 'w') as f:
    for i, r in enumerate(rmsd):
        f.write(f'snapshot {i}: rmsd={r:8.3f}\n')

